name: Deploy to Production

on:
  # Production deployments are manual only
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to deploy (e.g., v1.0.0)'
        required: true
        type: string
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        type: choice
        options:
          - blue-green
          - rolling
        default: blue-green

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOY_ENV: production

jobs:
  # Approval gate
  approval:
    name: Require Manual Approval
    runs-on: ubuntu-latest
    environment:
      name: production-approval
    steps:
      - name: Approval Required
        run: |
          echo "========================================="
          echo "PRODUCTION DEPLOYMENT APPROVAL REQUIRED"
          echo "========================================="
          echo "Version: ${{ github.event.inputs.version }}"
          echo "Strategy: ${{ github.event.inputs.deployment_strategy }}"
          echo "Triggered by: ${{ github.actor }}"
          echo "========================================="

  # Pre-deployment validation
  pre-deploy:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    needs: approval
    outputs:
      image_exists: ${{ steps.check-image.outputs.exists }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Validate version tag
        run: |
          # Check if version tag exists
          if ! git rev-parse "${{ github.event.inputs.version }}" >/dev/null 2>&1; then
            echo "ERROR: Version tag ${{ github.event.inputs.version }} does not exist!"
            exit 1
          fi

          echo "Version tag validated: ${{ github.event.inputs.version }}"

      - name: Check if Docker image exists
        id: check-image
        run: |
          # Try to pull the image
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.version }} && \
          echo "exists=true" >> $GITHUB_OUTPUT || \
          echo "exists=false" >> $GITHUB_OUTPUT

      - name: Verify image exists
        if: steps.check-image.outputs.exists != 'true'
        run: |
          echo "ERROR: Docker image not found for version ${{ github.event.inputs.version }}"
          echo "Please ensure the image is built and pushed first."
          exit 1

      - name: Run security scan on production image
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.event.inputs.version }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'  # Fail if vulnerabilities found

      - name: Validate database migrations
        run: |
          echo "Checking for breaking migrations..."
          # Add migration validation logic here
          echo "Migration validation passed"

  # Database backup before deployment
  backup:
    name: Backup Production Database
    runs-on: ubuntu-latest
    needs: pre-deploy
    environment:
      name: production

    steps:
      - name: Trigger database backup
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PRODUCTION_DB_HOST }}
          username: ${{ secrets.PRODUCTION_SSH_USER }}
          key: ${{ secrets.PRODUCTION_SSH_KEY }}
          script: |
            echo "Creating pre-deployment database backup..."

            BACKUP_NAME="pre-deploy-${{ github.event.inputs.version }}-$(date +%Y%m%d-%H%M%S)"

            # Create backup
            mysqldump -h ${{ secrets.DB_HOST }} \
              -u ${{ secrets.DB_USER }} \
              -p${{ secrets.DB_PASSWORD }} \
              ${{ secrets.DB_NAME }} \
              --single-transaction \
              --quick \
              --lock-tables=false \
              > /backups/${BACKUP_NAME}.sql

            # Compress backup
            gzip /backups/${BACKUP_NAME}.sql

            # Upload to S3
            aws s3 cp /backups/${BACKUP_NAME}.sql.gz \
              s3://${{ secrets.BACKUP_S3_BUCKET }}/production/${BACKUP_NAME}.sql.gz

            echo "Backup completed: ${BACKUP_NAME}.sql.gz"

      - name: Verify backup
        run: |
          echo "Verifying backup exists in S3..."
          # Add S3 verification logic
          echo "Backup verified"

  # Blue-Green Deployment
  deploy-blue-green:
    name: Deploy (Blue-Green)
    runs-on: ubuntu-latest
    needs: [pre-deploy, backup]
    if: github.event.inputs.deployment_strategy == 'blue-green'
    environment:
      name: production
      url: https://api.your-domain.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config

      - name: Determine current active deployment
        id: active
        run: |
          # Check which deployment is currently active
          ACTIVE=$(kubectl get service todo-app-prod -o jsonpath='{.spec.selector.version}')
          echo "Current active: $ACTIVE"

          if [ "$ACTIVE" = "blue" ]; then
            echo "target=green" >> $GITHUB_OUTPUT
            echo "current=blue" >> $GITHUB_OUTPUT
          else
            echo "target=blue" >> $GITHUB_OUTPUT
            echo "current=green" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to ${{ steps.active.outputs.target }} environment
        run: |
          TARGET=${{ steps.active.outputs.target }}
          VERSION=${{ github.event.inputs.version }}

          echo "Deploying version $VERSION to $TARGET environment..."

          # Update deployment with new image
          kubectl set image deployment/todo-app-${TARGET} \
            app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION} \
            -n production

          # Wait for rollout to complete
          kubectl rollout status deployment/todo-app-${TARGET} -n production --timeout=10m

      - name: Run database migrations on ${{ steps.active.outputs.target }}
        run: |
          TARGET=${{ steps.active.outputs.target }}

          # Get pod name
          POD=$(kubectl get pod -l app=todo-app,version=${TARGET} -n production -o jsonpath='{.items[0].metadata.name}')

          echo "Running migrations on pod: $POD"

          kubectl exec $POD -n production -- bundle exec rails db:migrate

      - name: Health check on ${{ steps.active.outputs.target }}
        run: |
          TARGET=${{ steps.active.outputs.target }}

          # Get pod IP
          POD_IP=$(kubectl get pod -l app=todo-app,version=${TARGET} -n production -o jsonpath='{.items[0].status.podIP}')

          echo "Running health check on $POD_IP..."

          # Port forward for health check
          kubectl port-forward -n production svc/todo-app-${TARGET} 8080:3000 &
          PF_PID=$!

          sleep 5

          # Health check
          curl -f http://localhost:8080/health || {
            kill $PF_PID
            echo "Health check failed!"
            exit 1
          }

          kill $PF_PID
          echo "Health check passed!"

      - name: Run smoke tests on ${{ steps.active.outputs.target }}
        run: |
          TARGET=${{ steps.active.outputs.target }}

          echo "Running smoke tests on $TARGET environment..."

          # Port forward for testing
          kubectl port-forward -n production svc/todo-app-${TARGET} 8080:3000 &
          PF_PID=$!

          sleep 5

          # Run smoke tests
          curl -f http://localhost:8080/health
          # Add more smoke tests here

          kill $PF_PID
          echo "Smoke tests passed!"

      - name: Switch traffic to ${{ steps.active.outputs.target }}
        run: |
          TARGET=${{ steps.active.outputs.target }}

          echo "Switching production traffic to $TARGET..."

          # Update service selector to point to new deployment
          kubectl patch service todo-app-prod -n production -p \
            '{"spec":{"selector":{"version":"'${TARGET}'"}}}'

          echo "Traffic switched to $TARGET!"

      - name: Monitor new deployment
        run: |
          echo "Monitoring new deployment for 2 minutes..."
          sleep 120

          # Check for errors
          kubectl logs -l app=todo-app,version=${{ steps.active.outputs.target }} \
            -n production --tail=50 | grep -i error || true

          echo "Monitoring complete"

      - name: Scale down old deployment
        run: |
          CURRENT=${{ steps.active.outputs.current }}

          echo "Scaling down old $CURRENT deployment..."

          kubectl scale deployment/todo-app-${CURRENT} --replicas=1 -n production

          echo "Old deployment scaled down (kept 1 replica for rollback)"

  # Rolling Deployment
  deploy-rolling:
    name: Deploy (Rolling)
    runs-on: ubuntu-latest
    needs: [pre-deploy, backup]
    if: github.event.inputs.deployment_strategy == 'rolling'
    environment:
      name: production
      url: https://api.your-domain.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.version }}

      - name: Configure kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up kubeconfig
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > $HOME/.kube/config

      - name: Update deployment image
        run: |
          VERSION=${{ github.event.inputs.version }}

          echo "Performing rolling update to version $VERSION..."

          kubectl set image deployment/todo-app-prod \
            app=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION} \
            -n production

          # Wait for rollout
          kubectl rollout status deployment/todo-app-prod -n production --timeout=15m

      - name: Run database migrations
        run: |
          # Get any pod from the new deployment
          POD=$(kubectl get pod -l app=todo-app -n production -o jsonpath='{.items[0].metadata.name}')

          kubectl exec $POD -n production -- bundle exec rails db:migrate

      - name: Verify deployment
        run: |
          # Check all pods are ready
          kubectl get pods -l app=todo-app -n production

          # Test health endpoint
          kubectl port-forward -n production svc/todo-app-prod 8080:3000 &
          PF_PID=$!

          sleep 5
          curl -f http://localhost:8080/health

          kill $PF_PID

  # Post-deployment validation
  post-deploy:
    name: Post-deployment Validation
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, deploy-rolling]
    if: always() && (needs.deploy-blue-green.result == 'success' || needs.deploy-rolling.result == 'success')

    steps:
      - name: Test production endpoints
        run: |
          echo "Testing production endpoints..."

          # Test health
          curl -f https://api.your-domain.com/health

          # Test API
          curl -f https://api.your-domain.com/api/v1

          echo "Production endpoints verified!"

      - name: Run E2E tests against production
        run: |
          echo "Running E2E tests..."
          # Add E2E test execution
          echo "E2E tests passed!"

      - name: Check error rates
        run: |
          echo "Checking error rates in monitoring..."
          # Query monitoring system for error rates
          echo "Error rates normal"

      - name: Tag successful deployment
        run: |
          git tag -a "deployed-prod-${{ github.event.inputs.version }}" \
            -m "Deployed to production: ${{ github.event.inputs.version }}"
          git push origin "deployed-prod-${{ github.event.inputs.version }}"

  # Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, deploy-rolling, post-deploy]
    if: always()

    steps:
      - name: Notify team on Slack
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "Production Deployment ${{ needs.deploy-blue-green.result == 'success' || needs.deploy-rolling.result == 'success' && '‚úÖ Succeeded' || '‚ùå Failed' }}",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "${{ needs.deploy-blue-green.result == 'success' || needs.deploy-rolling.result == 'success' && '‚úÖ Production Deployment Successful' || '‚ùå Production Deployment Failed' }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ github.event.inputs.version }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Strategy:*\n${{ github.event.inputs.deployment_strategy }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Deployed by:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*URL:*\nhttps://api.your-domain.com"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Logs"
                      },
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "Monitoring"
                      },
                      "url": "https://monitoring.your-domain.com"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Send email notification
        if: failure()
        run: |
          echo "Sending failure notification email..."
          # Add email notification logic

  # Rollback procedure
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    needs: [deploy-blue-green, deploy-rolling]
    if: failure()
    environment:
      name: production-rollback

    steps:
      - name: Rollback deployment
        run: |
          echo "‚ö†Ô∏è INITIATING PRODUCTION ROLLBACK ‚ö†Ô∏è"

          # Rollback Kubernetes deployment
          kubectl rollout undo deployment/todo-app-prod -n production

          # Wait for rollback to complete
          kubectl rollout status deployment/todo-app-prod -n production

      - name: Verify rollback
        run: |
          # Test health after rollback
          kubectl port-forward -n production svc/todo-app-prod 8080:3000 &
          PF_PID=$!

          sleep 5
          curl -f http://localhost:8080/health

          kill $PF_PID

          echo "Rollback completed and verified"

      - name: Notify rollback
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "üö® PRODUCTION ROLLBACK INITIATED üö®",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "üö® Production Rollback"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Production deployment of version `${{ github.event.inputs.version }}` failed and was automatically rolled back."
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
